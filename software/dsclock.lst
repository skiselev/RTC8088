     1                                  ;=========================================================================
     2                                  ; clock.asm - MS-DOS Clock driver 
     3                                  ;-------------------------------------------------------------------------
     4                                  ;
     5                                  ; Compiles with NASM 2.13.02, might work with other versions
     6                                  ;
     7                                  ; Copyright (C) 2024 - Sergey Kiselev.
     8                                  ; Provided for hobbyist use with the RTC8088 boards.
     9                                  ;
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;
    23                                  ;=========================================================================
    24                                  
    25                                  	cpu	8086
    26                                  
    27                                  ;-------------------------------------------------------------------------
    28                                  ; RTC default I/O port
    29                                  default_io_port	equ	240h
    30                                  
    31                                  ;-------------------------------------------------------------------------
    32                                  ; locations in RTC and NVRAM
    33                                  cmos_seconds	equ	00h	; seconds location in RTC
    34                                  cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
    35                                  cmos_minutes	equ	02h	; minutes location in RTC
    36                                  cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
    37                                  cmos_hours	equ	04h	; hours locaiton in RTC
    38                                  cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
    39                                  cmos_day	equ	06h	; day location in RTC
    40                                  cmos_date	equ	07h	; date location in RTC
    41                                  cmos_month	equ	08h	; month location in RTC
    42                                  cmos_year	equ	09h	; year location in RTC
    43                                  cmos_floppy	equ	10h	; floppy type byte
    44                                  cmos_equip	equ	14h	; equipment byte
    45                                  cmos_config_a	equ	2Dh	; BIOS configuration byte A
    46                                  cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
    47                                  cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
    48                                  cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
    49                                  
    50                                  ;-------------------------------------------------------------------------
    51                                  ; RTC control register and their bits
    52                                  cmos_control_a	equ	0Ah	; RTC control A register
    53                                  cmos_uip	equ	80h	; RTC update in progress bit
    54                                  cmos_control_b	equ	0Bh	; RTC control B register
    55                                  cmos_dse	equ	01h	; RTC daylight savings enable bit
    56                                  cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
    57                                  cmos_uie	equ	10h	; RTC update ended interrupt enable bit
    58                                  cmos_aie	equ	20h	; RTC alarm interrupt enable bit
    59                                  cmos_pie	equ	40h	; RTC periodic interrupt enable bit
    60                                  cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
    61                                  cmos_control_c	equ	0Ch	; RTC control C register
    62                                  cmos_uf		equ	20h	; RTC update ended interrupt flag
    63                                  cmos_af		equ	40h	; RTC alarm interrupt flag
    64                                  cmos_pf		equ	80h	; RTC periodic interrupt flag
    65                                  cmos_control_d	equ	0Dh	; RTC control D register
    66                                  cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
    67                                  
    68                                  ;-------------------------------------------------------------------------
    69                                  ; Device driver - Request header - common fields (13 bytes)
    70                                  cmdlen		equ	0	; Length of this command (1 byte)
    71                                  unit		equ	1	; Subunit Specified (1 byte)
    72                                  cmd		equ	2	; Command Code (1 byte)
    73                                  status		equ	3	; Status (2 bytes / 1 word)
    74                                  reserved	equ 	5	; Reserved (8 bytes)
    75                                  ; Device driver - Request header - Init function
    76                                  num_units	equ	13	; Number of units (1 byte)
    77                                  end_addr	equ	14	; End address of the driver (dword/4 bytes)
    78                                  cmd_addr	equ	18	; Pointer to command line arguments + CR/LF
    79                                  ; Device driver - Request header - Read/Write functions
    80                                  transfer_addr	equ	14	; Transfer address (dword/4 bytes)
    81                                  
    82                                  ;-------------------------------------------------------------------------
    83                                  ; Device driver - Commands and status
    84                                  cmd_init	equ	0h	; "Init" command
    85                                  cmd_read	equ	4h	; "Read" command
    86                                  cmd_write	equ	8h	; "Write" command
    87                                  status_done	equ	0100h	; "Done" status, bit 8 set
    88                                  status_fail	equ	800Ch	; "Error" - bit 15 set + "General Failure" - 0Ch
    89                                  
    90                                  ;-------------------------------------------------------------------------
    91                                  ; MS-DOS reads or writes the following 6-byte sequence to clock device:
    92                                  clk_days	equ	0h	; days since 01/01/1980 - word
    93                                  clk_minutes	equ	2h	; minutes - byte
    94                                  clk_hours	equ	3h	; hours - byte
    95                                  clk_cseconds	equ	4h	; centiseconds - byte
    96                                  clk_seconds	equ	5h	; seconds - byte 
    97                                  
    98                                  	org	0h		; device drivers start at the offset 0h
    99                                  
   100                                  ;=========================================================================
   101                                  ; Device driver header
   102                                  ;-------------------------------------------------------------------------
   103 00000000 FFFFFFFF                device_header	dw	0FFFFh, 0FFFFh	; next device pointer - last device
   104 00000004 0880                    		dw	1000000000001000b ; driver attributes
   105                                  ;			|           `--- clock device
   106                                  ;			`--------------- character device
   107 00000006 [3600]                  		dw	strategy	; strategy entry point
   108 00000008 [4100]                  		dw	entry		; device driver entry point
   109 0000000A 434C4F434B242020        		db	'CLOCK$  '	; device name
   110                                  
   111                                  ;=========================================================================
   112                                  ; Clock driver data
   113                                  ;-------------------------------------------------------------------------
   114 00000012 00000000                request_ptr	dd	0		; pointer to the request header
   115 00000016 4002                    rtc_io_port	dw	0240h		; use I/O port 240h by default
   116 00000018 0000                    seconds		db	cmos_seconds,0	; last seconds value read or written
   117 0000001A 0200                    minutes		db	cmos_minutes,0	; last minutes value read or written
   118 0000001C 0400                    hours		db	cmos_hours,0	; last hours value read or written
   119 0000001E 0600                    day		db	cmos_day,0	; last day value read or written
   120 00000020 0700                    date		db	cmos_date,0	; last date value read or written
   121 00000022 0800                    month		db	cmos_month,0	; last month value read or written
   122 00000024 0900                    year		db	cmos_year,0	; last year value read or written
   123 00000026 3200                    century		db	cmos_century,0	; last century value read or written
   124                                  num_rtc_regs	equ	($-seconds)/2	; number of RTC registers
   125 00000028 0000                    ticks		dw	0		; initial ticks value for read time
   126 0000002A 1F1C1F1E1F1E1F1F1E-     days_in_month	db	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
   126 00000033 1F1E1F             
   127                                  
   128                                  ;=========================================================================
   129                                  ; strategy - MS-DOS calls this function first, passing the request header
   130                                  ;            address. This function stores that address in request_ptr
   131                                  ; Input:
   132                                  ;	ES:BX = request header address
   133                                  ; Output:
   134                                  ;	none
   135                                  ;-------------------------------------------------------------------------
   136                                  strategy:
   137 00000036 2E891E[1200]            	mov	cs:[request_ptr],bx	; save request header address
   138 0000003B 2E8C06[1400]            	mov	cs:[request_ptr+2],es
   139 00000040 CB                      	retf
   140                                  
   141                                  ;=========================================================================
   142                                  ; entry - MS-DOS calls this function to perform the operation
   143                                  ; Input:
   144                                  ;	none; strategy subroutine is called first with the request header
   145                                  ; Output:
   146                                  ;	[request_ptr] is populated for init, read, and write functions
   147                                  ;	[transfer_addr] is populated for the read function
   148                                  ;-------------------------------------------------------------------------
   149                                  entry:
   150 00000041 9C                      	pushf				; save the registers on the stack
   151 00000042 06                      	push	es
   152 00000043 1E                      	push	ds
   153 00000044 50                      	push	ax
   154 00000045 53                      	push	bx
   155 00000046 51                      	push	cx
   156 00000047 52                      	push	dx
   157 00000048 56                      	push	si
   158 00000049 57                      	push	di
   159 0000004A FC                      	cld
   160 0000004B 2EC51E[1200]            	lds	bx,cs:[request_ptr]	; load request header pointer to DS:BX
   161 00000050 C747030001              	mov	word [bx+status],status_done	; set return status to "done"
   162 00000055 8A4702                  	mov	al,[bx+cmd]		; load command code to AL
   163 00000058 3C00                    	cmp	al,cmd_init		; "Init" command?
   164 0000005A 7503E93A02              	je	init			; jump to init subroutine
   165 0000005F 8B770E                  	mov	si,[bx+transfer_addr]	; SI = clock data sequence
   166 00000062 3C04                    	cmp	al,cmd_read		; "Read" command?
   167 00000064 7416                    	je	read			; jump to read subroutine
   168 00000066 3C08                    	cmp	al,cmd_write		; "Write" command?
   169 00000068 7503E9C700              	je	write			; jump to write subroutine
   170                                  error:
   171 0000006D C747030C80              	mov	word [bx+status],status_fail	; invalid function number
   172                                  exit:
   173 00000072 5F                      	pop	di
   174 00000073 5E                      	pop	si
   175 00000074 5A                      	pop	dx
   176 00000075 59                      	pop	cx
   177 00000076 5B                      	pop	bx
   178 00000077 58                      	pop	ax
   179 00000078 1F                      	pop	ds
   180 00000079 07                      	pop	es
   181 0000007A 9D                      	popf
   182 0000007B CB                      	retf
   183                                  
   184                                  ;=========================================================================
   185                                  ; read - Read (get) time
   186                                  ; Input:
   187                                  ;	[SI] = 6-byte sequence with the values for the clock
   188                                  ; Output:
   189                                  ;	[SI] = 6-byte sequence populated with the current clock date and time
   190                                  ;-------------------------------------------------------------------------
   191                                  read:
   192 0000007C E89D01                  	call	rtc_get			; get current time and date
   193 0000007F 9C                      	pushf				; save time changed flag
   194 00000080 2EA0[1D00]              	mov	al,cs:[hours+1]		; AL = BSD hours
   195 00000084 E8F601                  	call	bcd_to_binary		; convert to binary
   196 00000087 884403                  	mov	[si+clk_hours],al
   197 0000008A 2EA0[1B00]              	mov	al,cs:[minutes+1]	; AL = BCD minutes
   198 0000008E E8EC01                  	call	bcd_to_binary		; convert to binary
   199 00000091 884402                  	mov	[si+clk_minutes],al
   200 00000094 2EA0[1900]              	mov	al,cs:[seconds+1]	; AL = BCD seconds
   201 00000098 E8E201                  	call	bcd_to_binary		; convert to binary
   202 0000009B 884405                  	mov	[si+clk_seconds],al
   203                                  
   204                                  ; DS12885 RTC provides time only down to 1 second
   205                                  ; DOS wants centisecond accuracy
   206                                  ; do our best to get that using system interval timer (~55 ms intervals)
   207                                  
   208 0000009E 51                      	push	cx
   209 0000009F 52                      	push	dx
   210 000000A0 B400                    	mov	ah,00h			; read system clock counter
   211 000000A2 CD1A                    	int	1Ah			; System Clock BIOS Services
   212 000000A4 89D0                    	mov	ax,dx			; AX = low word of tick count
   213 000000A6 5A                      	pop	dx
   214 000000A7 59                      	pop	cx
   215 000000A8 9D                      	popf				; ZF = time changed flag
   216 000000A9 750F                    	jnz	.reset_ticks		; time changed since last call
   217                                  
   218                                  ; Still the same time (up to seconds)
   219                                  ; calculate the centisecond based on ticks difference
   220                                  
   221 000000AB 2E2B06[2800]            	sub	ax,cs:[ticks]		; find the difference between the
   222                                  					; current and the previous ticks count
   223                                  					; we should't care for roll-over
   224                                  					; because the difference should not be
   225                                  					; more than 18 ticks...
   226                                  	
   227 000000B0 B20B                    	mov	dl,11			; 11 2-centisecond intervals per tick
   228 000000B2 F6E2                    	mul	dl			; AX = centiseconds * 2
   229 000000B4 88C2                    	mov	dl,al			; DL = centiseconds * 2
   230 000000B6 D0EA                    	shr	dl,1			; DL = centiseconds
   231 000000B8 EB06                    	jmp	.return_cseconds
   232                                  
   233                                  .reset_ticks:
   234 000000BA 2EA3[2800]              	mov	cs:[ticks],ax		; store ticks value
   235 000000BE B200                    	mov	dl,0			; centiseconds = 0
   236                                  
   237                                  .return_cseconds:
   238 000000C0 885404                  	mov	[si+clk_cseconds],dl
   239                                  
   240                                  ; calculate days since 1/1/1980
   241                                  
   242 000000C3 2EA0[2700]              	mov	al,cs:[century+1]	; AL = BCD century
   243 000000C7 E8B301                  	call	bcd_to_binary
   244 000000CA 88C5                    	mov	ch,al			; CH = binary century
   245 000000CC 2EA0[2500]              	mov	al,cs:[year+1]		; AL = BCD year
   246 000000D0 E8AA01                  	call	bcd_to_binary
   247 000000D3 88C1                    	mov	cl,al			; CL = binary year
   248 000000D5 2EA0[2300]              	mov	al,cs:[month+1]		; AL = BCD month
   249 000000D9 E8A101                  	call	bcd_to_binary
   250 000000DC 88C6                    	mov	dh,al			; DH = binary month
   251 000000DE 2EA0[2100]              	mov	al,cs:[date+1]		; AL = BCD date
   252 000000E2 E89801                  	call	bcd_to_binary
   253 000000E5 88C2                    	mov	dl,al			; DL = binary date
   254                                  
   255 000000E7 53                      	push	bx
   256 000000E8 31DB                    	xor	bx,bx			; result - days since 1/1/1980
   257                                  
   258 000000EA 80FD14                  	cmp	ch,20			; is it 21st century (year 20xx)?
   259 000000ED 7405                    	je	.twentyfirst
   260 000000EF 80E950                  	sub	cl,80			; 20th century, subtract 80 from year
   261 000000F2 EB03                    	jmp	.add_leap_years
   262                                  .twentyfirst:
   263 000000F4 80C114                  	add	cl,20			; 21th century, add 20 to the year
   264                                  .add_leap_years:
   265 000000F7 88CB                    	mov	bl,cl			; years since 1980
   266 000000F9 D1EB                    	shr	bx,1			; BX /= 4 - number of leap years
   267 000000FB D1EB                    	shr	bx,1
   268                                  
   269 000000FD B500                    	mov	ch,0
   270 000000FF B86D01                  	mov	ax,365			; days in a year
   271 00000102 52                      	push	dx			; DX gets modified by multiplication
   272 00000103 F7E1                    	mul	cx			; DX:AX = days in the years so far
   273 00000105 5A                      	pop	dx
   274 00000106 01C3                    	add	bx,ax			; add the days in the past years
   275                                  
   276 00000108 F6C103                  	test	cl,3			; is it a leap year?
   277 0000010B 7403                    	je	.leap_year
   278 0000010D 43                      	inc	bx			; add a day for the previous leap year
   279 0000010E EB06                    	jmp	.add_months
   280                                  
   281                                  .leap_year:
   282 00000110 80FE02                  	cmp	dh,2			; leap year, before March?
   283 00000113 7601                    	jna	.add_months
   284 00000115 43                      	inc	bx			; add an extra day for Feburary
   285                                  
   286                                  .add_months:
   287 00000116 8D3E[2A00]              	lea	di,[days_in_month]	; table with number of days per month
   288 0000011A 88F1                    	mov	cl,dh			; CL - current month (1-12)
   289 0000011C EB07                    	jmp	.add_months_next	; first decrement month, then add
   290                                  
   291                                  .add_months_loop:
   292 0000011E 2E021D                  	add	bl,byte cs:[di]		; add number of days in the month
   293 00000121 80D700                  	adc	bh,0			; add the carry
   294 00000124 47                      	inc	di			; move to the next month
   295                                  
   296                                  .add_months_next:
   297 00000125 E2F7                    	loop	.add_months_loop
   298                                  
   299 00000127 FECA                    	dec	dl			; date is 1 based, make it 0 based
   300 00000129 00D3                    	add	bl,dl			; add the current day of the month
   301 0000012B 80D700                  	adc	bh,0			; add the carry
   302                                  	
   303 0000012E 891C                    	mov	[si+clk_days],bx	; return the result to DOS
   304 00000130 5B                      	pop	bx
   305                                  
   306 00000131 E93EFF                  	jmp	exit
   307                                  
   308                                  ;=========================================================================
   309                                  ; write - Write (set) time
   310                                  ; Input:
   311                                  ;	[SI] = 6-byte sequence with the values for the clock
   312                                  ; Output:
   313                                  ;	none
   314                                  ;-------------------------------------------------------------------------
   315                                  write:
   316 00000134 8A4403                  	mov	al,byte [si+clk_hours]
   317 00000137 E85201                  	call	binary_to_bcd		; convert to BCD
   318 0000013A 2EA2[1D00]              	mov	cs:[hours+1],al		; save BCD hours
   319 0000013E 8A4402                  	mov	al,byte [si+clk_minutes]
   320 00000141 E84801                  	call	binary_to_bcd		; convert to BCD
   321 00000144 2EA2[1B00]              	mov	cs:[minutes+1],al	; save BCD minutes
   322 00000148 8A4405                  	mov	al,byte [si+clk_seconds]
   323 0000014B E83E01                  	call	binary_to_bcd		; convert to BCD
   324 0000014E 2EA2[1900]              	mov	cs:[seconds+1],al	; save BCD seconds
   325                                  
   326 00000152 53                      	push	bx
   327                                  
   328 00000153 8B04                    	mov	ax,word [si+clk_days]	; days since 1/1/1980
   329                                  
   330                                  ; calculate the day of the week
   331                                  
   332 00000155 50                      	push	ax
   333 00000156 83C002                  	add	ax,2			; January 1st 1980 is a Tuesday
   334 00000159 31D2                    	xor	dx,dx			; DX:AX - days since 1/1/1980
   335 0000015B BB0700                  	mov	bx,7			; 7 days a week
   336 0000015E F7F3                    	div	bx			; DL - remainer day of the week
   337 00000160 FEC2                    	inc	dl			; days of the week are 1-based
   338 00000162 2E8816[1F00]            	mov	cs:[day+1],dl		; save day of the week
   339 00000167 58                      	pop	ax
   340                                  
   341                                  ; calculate the date
   342                                  
   343 00000168 B9B505                  	mov	cx,1461			; 1461 in a 4 year cycle (365*3+366)
   344 0000016B 31D2                    	xor	dx,dx			; DX:AX = days since 1/1/1980
   345 0000016D F7F1                    	div	cx			; AX = number of 4 year cycles
   346 0000016F 01C0                    	add	ax,ax			; AX = AX * 4 - number of years
   347 00000171 01C0                    	add	ax,ax			; since 1/1/1980 modulo 4
   348 00000173 88C1                    	mov	cl,al			; CL = years modulo 4
   349 00000175 80C150                  	add	cl,80			; the starting year is 1980
   350 00000178 B513                    	mov	ch,19			; CH = century, assume 20th century
   351 0000017A 80F964                  	cmp	cl,100
   352 0000017D 7205                    	jb	.twentieth_century	; the year is below 100?
   353 0000017F 80E964                  	sub	cl,100			; subtract 100 from the year
   354 00000182 FEC5                    	inc	ch			; increment the century
   355                                  
   356                                  .twentieth_century:
   357 00000184 89D0                    	mov	ax,dx			; AX - remainder = the day in the
   358                                  					; current 4 year cycle
   359                                  
   360 00000186 83F83B                  	cmp	ax,59			; February 29 of a leap year?
   361 00000189 7209                    	jb	.calculate_year
   362 0000018B 7706                    	ja	.past_february		
   363 0000018D B602                    	mov	dh,2			; February
   364 0000018F B21D                    	mov	dl,29			; 29
   365 00000191 EB26                    	jmp	.set_date
   366                                  
   367                                  .past_february:
   368 00000193 48                      	dec	ax			; decrement a day for the leap year
   369                                  
   370                                  .calculate_year:
   371 00000194 BB6D01                  	mov	bx,365			; 365 days in a year
   372 00000197 31D2                    	xor	dx,dx			; DX:AX = the day in the current
   373                                  					; 4 year cycle
   374 00000199 F7F3                    	div	bx			; AX = year in the 4 year cycle
   375                                  					; DX = day in the current year
   376 0000019B 00C1                    	add	cl,al			; CL = year
   377                                  
   378 0000019D 31DB                    	xor	bx,bx			; BH = month, BL = date
   379 0000019F B400                    	mov	ah,0
   380 000001A1 8D3E[2A00]              	lea	di,[days_in_month]
   381                                  
   382                                  .add_months_loop:
   383 000001A5 2E8A05                  	mov	al,cs:[di]		; AL - number of days in the month
   384 000001A8 39C2                    	cmp	dx,ax			; the current day is below the number
   385 000001AA 7207                    	jb	.add_months_done	; of days in the current month?
   386 000001AC 29C2                    	sub	dx,ax			; subtract the days in the month
   387 000001AE 47                      	inc	di			; move to the next month
   388 000001AF FEC7                    	inc	bh			; increment month count
   389 000001B1 EBF2                    	jmp	.add_months_loop
   390                                  
   391                                  .add_months_done:
   392 000001B3 88FE                    	mov	dh,bh			; BH = month
   393 000001B5 FEC6                    	inc	dh			; months are 1 based
   394 000001B7 FEC2                    	inc	dl			; dates are 1 based
   395                                  
   396                                  .set_date:
   397 000001B9 88E8                    	mov	al,ch
   398 000001BB E8CE00                  	call	binary_to_bcd
   399 000001BE 2EA2[2700]              	mov	cs:[century+1],al	; save BCD century
   400 000001C2 88C8                    	mov	al,cl
   401 000001C4 E8C500                  	call	binary_to_bcd
   402 000001C7 2EA2[2500]              	mov	cs:[year+1],al		; save BCD year
   403 000001CB 88F0                    	mov	al,dh
   404 000001CD E8BC00                  	call	binary_to_bcd
   405 000001D0 2EA2[2300]              	mov	cs:[month+1],al		; save BCD month
   406 000001D4 88D0                    	mov	al,dl
   407 000001D6 E8B300                  	call	binary_to_bcd
   408 000001D9 2EA2[2100]              	mov	cs:[date+1],al		; save BCD date
   409                                  
   410 000001DD E80400                  	call	rtc_set
   411                                  
   412 000001E0 5B                      	pop	bx
   413                                  
   414 000001E1 E98EFE                  	jmp	exit
   415                                  
   416                                  ;=========================================================================
   417                                  ; rtc_set - Set real time clock
   418                                  ; Input:
   419                                  ;	cs:[seconds] - pairs of the RTC register number + RTC value
   420                                  ; Output:
   421                                  ;	None
   422                                  ;-------------------------------------------------------------------------
   423                                  rtc_set:
   424 000001E4 50                      	push	ax
   425 000001E5 51                      	push	cx
   426 000001E6 56                      	push	si
   427 000001E7 1E                      	push	ds
   428 000001E8 8CC8                    	mov	ax,cs
   429 000001EA 8ED8                    	mov	ds,ax			; DS = CS
   430 000001EC B00B                    	mov	al,cmos_control_b
   431 000001EE E85E00                  	call	rtc_read		; read control B register
   432 000001F1 88C4                    	mov	ah,al
   433 000001F3 80CC80                  	or	ah,cmos_set		; set the RTC set bit
   434 000001F6 B00B                    	mov	al,cmos_control_b
   435 000001F8 E86900                  	call	rtc_write		; write control B register
   436                                  
   437 000001FB B90800                  	mov	cx,num_rtc_regs		; number of iterations
   438 000001FE BE[1800]                	mov	si,seconds		; the address of the first RTC value
   439 00000201 FC                      	cld
   440                                  
   441                                  rtc_set_loop:
   442 00000202 AD                      	lodsw				; AX = DS:[SI], SI += 2
   443                                  					; AL - RTC register number
   444                                  					; AH - value to write to the RTC
   445 00000203 E85E00                  	call	rtc_write		; write it to the RTC
   446 00000206 E2FA                    	loop	rtc_set_loop
   447                                  
   448 00000208 B00B                    	mov	al,cmos_control_b
   449 0000020A E84200                  	call	rtc_read		; read control B register
   450 0000020D 88C4                    	mov	ah,al
   451 0000020F 80E47F                  	and	ah,~cmos_set		; clear the RTC set bit
   452 00000212 B00B                    	mov	al,cmos_control_b
   453 00000214 E84D00                  	call	rtc_write		; write control B register
   454 00000217 1F                      	pop	ds
   455 00000218 5E                      	pop	si
   456 00000219 59                      	pop	cx
   457 0000021A 58                      	pop	ax
   458 0000021B C3                      	ret
   459                                  
   460                                  ;=========================================================================
   461                                  ; rtc_get - Get real time clock
   462                                  ; Input:
   463                                  ;	cs:[seconds] - pairs of the RTC register number + previous RTC value
   464                                  ; Output:
   465                                  ;	ZF - time changed from the previous call flag
   466                                  ;	     ZF = 0 - time not changed
   467                                  ;	     ZF = 1 - time changed
   468                                  ;	cs:[seconds] - pairs of the RTC register number + current RTC value
   469                                  ;-------------------------------------------------------------------------
   470                                  rtc_get:
   471 0000021C 50                      	push	ax
   472 0000021D 51                      	push	cx
   473 0000021E 52                      	push	dx
   474 0000021F 56                      	push	si
   475 00000220 1E                      	push	ds
   476 00000221 8CC8                    	mov	ax,cs
   477 00000223 8ED8                    	mov	ds,ax			; DS = CS
   478 00000225 31D2                    	xor	dx,dx			; reset time changed flag
   479                                  
   480                                  .wait_for_update:
   481 00000227 B00A                    	mov	al,cmos_control_a
   482 00000229 E82300                  	call	rtc_read		; read control A register
   483 0000022C A880                    	test	al,cmos_uip
   484 0000022E E0F7                    	loopnz	.wait_for_update	; wait for the update to complete
   485 00000230 7515                    	jnz	.exit			; timeout waiting for the update
   486                                  
   487 00000232 B90800                  	mov	cx,num_rtc_regs		; number of iterations
   488 00000235 BE[1800]                	mov	si,seconds		; the address of the first RTC value
   489 00000238 FC                      	cld
   490                                  
   491                                  .rtc_get_loop:
   492 00000239 AD                      	lodsw				; AX = DS:[SI], SI += 2
   493                                  					; AL - RTC register number
   494                                  					; AH = previous value
   495 0000023A E81200                  	call	rtc_read
   496 0000023D 38E0                    	cmp	al,ah			; compare previous and current values
   497 0000023F 7401                    	je	.rtc_get_loop_continue
   498 00000241 42                      	inc 	dx			; set time changed flag
   499                                  
   500                                  .rtc_get_loop_continue:
   501 00000242 8844FF                  	mov	[si-1],al		; save the new value
   502 00000245 E2F2                    	loop	.rtc_get_loop
   503                                  
   504                                  .exit:
   505 00000247 09D2                    	or	dx,dx			; ZF = time changed flag
   506 00000249 1F                      	pop	ds
   507 0000024A 5E                      	pop	si
   508 0000024B 5A                      	pop	dx
   509 0000024C 59                      	pop	cx
   510 0000024D 58                      	pop	ax
   511 0000024E C3                      	ret
   512                                  
   513                                  ;=========================================================================
   514                                  ; rtc_read - Read byte from RTC or CMOS memory
   515                                  ; Input:
   516                                  ;	AL - address of byte to read
   517                                  ; Output:
   518                                  ;	AL - byte from RTC
   519                                  ;-------------------------------------------------------------------------
   520                                  rtc_read:
   521 0000024F 52                      	push	dx
   522 00000250 2E8B16[1600]            	mov	dx,cs:[rtc_io_port]
   523 00000255 FA                      	cli
   524 00000256 EE                      	out	dx,al
   525 00000257 EB00                    	jmp	$+2			; I/O delay
   526 00000259 EB00                    	jmp	$+2
   527 0000025B EB00                    	jmp	$+2
   528 0000025D EB00                    	jmp	$+2
   529 0000025F 42                      	inc	dx			; DX = RTC data register
   530 00000260 EC                      	in	al,dx
   531 00000261 FB                      	sti
   532 00000262 5A                      	pop	dx
   533 00000263 C3                      	ret
   534                                  
   535                                  ;=========================================================================
   536                                  ; rtc_write - Write byte to RTC or CMOS memory
   537                                  ; Input:
   538                                  ;	AL - address of byte to write
   539                                  ;	AH - byte to write to RTC
   540                                  ; Output:
   541                                  ;	none
   542                                  ;-------------------------------------------------------------------------
   543                                  rtc_write:
   544 00000264 52                      	push	dx
   545 00000265 2E8B16[1600]            	mov	dx,cs:[rtc_io_port]
   546 0000026A FA                      	cli
   547 0000026B EE                      	out	dx,al
   548 0000026C EB00                    	jmp	$+2			; I/O delay
   549 0000026E EB00                    	jmp	$+2
   550 00000270 EB00                    	jmp	$+2
   551 00000272 EB00                    	jmp	$+2
   552 00000274 86C4                    	xchg	ah,al
   553 00000276 42                      	inc	dx			; DX = RTC data register
   554 00000277 EE                      	out	dx,al
   555 00000278 86C4                    	xchg	ah,al
   556 0000027A FB                      	sti
   557 0000027B 5A                      	pop	dx
   558 0000027C C3                      	ret
   559                                  
   560                                  ;=========================================================================
   561                                  ; bcd_to_binary - convert 8-bit BCD number to binary
   562                                  ; Input:
   563                                  ;	AL - BCD number
   564                                  ; Output:
   565                                  ;	AL - binary number
   566                                  ;	AH = 0
   567                                  ;-------------------------------------------------------------------------
   568                                  bcd_to_binary:
   569 0000027D 88C4                    	mov	ah,al			; calculate tens
   570 0000027F 240F                    	and	al,0Fh			; AL = ones
   571 00000281 D0EC                    	shr	ah,1
   572 00000283 D0EC                    	shr	ah,1
   573 00000285 D0EC                    	shr	ah,1
   574 00000287 D0EC                    	shr	ah,1			; AH = tens
   575 00000289 D50A                    	aad				; AL = AH * 10 + AL ; AH = 0
   576 0000028B C3                      	ret
   577                                  
   578                                  ;=========================================================================
   579                                  ; binary_to_bcd - convert 8-bit binary number to BCD
   580                                  ; Input:
   581                                  ;	AL - binary number
   582                                  ; Output:
   583                                  ;	AL - BCD number
   584                                  ;	AH - trashed
   585                                  ;-------------------------------------------------------------------------
   586                                  binary_to_bcd:
   587 0000028C D40A                    	aam				; AH = AL / 10 ; AL = AL % 10
   588 0000028E D0E4                    	shl	ah,1			; shift tens to 4 higher bits
   589 00000290 D0E4                    	shl	ah,1
   590 00000292 D0E4                    	shl	ah,1
   591 00000294 D0E4                    	shl	ah,1
   592 00000296 00E0                    	add	al,ah			; add tens to ones
   593 00000298 C3                      	ret
   594                                  
   595                                  ;=========================================================================
   596                                  ; init - Initialize the device driver
   597                                  ; Input:
   598                                  ;	[bx+cmd_addr] - address of the command line arguments (dword)
   599                                  ; Output:
   600                                  ;	[bx+num_units] = 1 - number of units (byte)
   601                                  ;	[bx+end_addr] - address of the end of the resident part (dword)
   602                                  ;-------------------------------------------------------------------------
   603                                  init:
   604                                  
   605                                  ; Print the sign-in message
   606                                  
   607 00000299 BA[DF05]                	mov	dx,msg_signin
   608 0000029C E8F802                  	call	print_string
   609                                  
   610                                  ;-------------------------------------------------------------------------
   611                                  ; Parse the command line
   612                                  ; - look for a hexadecimal number - I/O port number
   613                                  ; - look for '/' option flag and the following character
   614                                  ; Implementation:
   615                                  ; - Skip all non-space characters
   616                                  ; - Skip all space and tab characters
   617                                  ; - Parse the number either in decimal or hexadecimal format
   618                                  ;   hexadecimal format uses 'x' as identifier, which might have one or
   619                                  ;   more zeros before it
   620                                  
   621 0000029F 31D2                    	xor	dx,dx			; DX = 0 - port number goes here
   622 000002A1 B100                    	mov	cl,0			; CL = 0 - hex indicator (0 = decimal)
   623 000002A3 1E                      	push	ds
   624 000002A4 C57712                  	lds	si,[bx+cmd_addr]	; DS:SI - command line
   625 000002A7 FC                      	cld
   626                                  
   627                                  .skip_drv_name_loop:
   628 000002A8 AC                      	lodsb
   629 000002A9 3C20                    	cmp	al,' '			; space
   630 000002AB 7407                    	je	.skip_space
   631 000002AD 3C09                    	cmp	al,09h			; TAB
   632 000002AF 7403                    	je	.skip_space
   633 000002B1 EBF5                    	jmp	.skip_drv_name_loop
   634                                  
   635                                  .skip_space_loop:
   636 000002B3 AC                      	lodsb
   637                                  
   638                                  .skip_space:
   639 000002B4 3C20                    	cmp	al,' '			; space
   640 000002B6 74FB                    	je	.skip_space_loop
   641 000002B8 3C09                    	cmp	al,09h			; TAB
   642 000002BA 74F7                    	je	.skip_space_loop
   643 000002BC 3C0D                    	cmp	al,0Dh			; CR - end of cmdline, stop parsing
   644 000002BE 7503E99100              	je	.port_check
   645 000002C3 3C0A                    	cmp	al,0Ah			; LF - end of cmdline, stop parsing
   646 000002C5 7503E98A00              	je	.port_check
   647 000002CA 3C2F                    	cmp	al,'/'			; '/' - options should follow
   648 000002CC 7417                    	je	.parse_options
   649 000002CE 09D2                    	or	dx,dx			; port number already has been set?
   650 000002D0 7403E99802              	jnz	invalid_argument
   651 000002D5 3C30                    	cmp	al,'0'			; otherwise we expect a number...
   652 000002D7 7303E99102              	jb	invalid_argument
   653 000002DC 3C39                    	cmp	al,'9'
   654 000002DE 7603E98A02              	ja	invalid_argument
   655 000002E3 EB13                    	jmp	.parse_port
   656                                  
   657                                  .parse_options:
   658 000002E5 AC                      	lodsb
   659 000002E6 0C20                    	or	al,20h			; convert letters to lower case
   660 000002E8 3C64                    	cmp	al,'d'			; DSE option?
   661 000002EA 7403E97E02              	jne	invalid_argument
   662 000002EF 2EC606[FC07]01          	mov	byte cs:[dse],cmos_dse	; set DSE option
   663 000002F5 EBBC                    	jmp	.skip_space_loop	; continue parsing command line args
   664                                  
   665                                  .parse_port_loop:
   666 000002F7 AC                      	lodsb
   667                                  
   668                                  .parse_port:
   669 000002F8 3C30                    	cmp	al,'0'			; below '0'?
   670 000002FA 72B8                    	jb	.skip_space		; check for Space, TAB, CR, LF, '/'...
   671 000002FC 3C39                    	cmp	al,'9'
   672 000002FE 762A                    	jna	.add_digit		; between '0' and '9' - add a digit
   673 00000300 0C20                    	or	al,20h			; convert letters to lower case
   674 00000302 3C78                    	cmp	al,'x'			; hexadecimal identifier?
   675 00000304 743A                    	je	.use_hex
   676 00000306 80F900                  	cmp	cl,0			; hex flag not set, but not a decimal?
   677 00000309 7503E95F02              	je	invalid_argument
   678 0000030E 3C61                    	cmp	al,'a'
   679 00000310 7303E95802              	jb	invalid_argument
   680 00000315 3C66                    	cmp	al,'f'
   681 00000317 7603E95102              	ja	invalid_argument
   682 0000031C 2C57                    	sub	al,'a'-10		; convert to binary
   683                                  
   684                                  .add_hex_digit:
   685 0000031E D1E2                    	shl	dx,1			; DX = DX << 4
   686 00000320 D1E2                    	shl	dx,1
   687 00000322 D1E2                    	shl	dx,1
   688 00000324 D1E2                    	shl	dx,1
   689 00000326 00C2                    	add	dl,al			; add the digit
   690 00000328 EBCD                    	jmp	.parse_port_loop
   691                                  
   692                                  .add_digit:
   693 0000032A 2C30                    	sub	al,'0'			; convert to binary
   694 0000032C 80F900                  	cmp	cl,0			; hex flag is set?
   695 0000032F 75ED                    	jne	.add_hex_digit		; then add a hex digit
   696 00000331 50                      	push	ax
   697 00000332 B80A00                  	mov	ax,10
   698 00000335 F7E2                    	mul	dx			; DX:AX = DX * 10
   699 00000337 89C2                    	mov	dx,ax
   700 00000339 58                      	pop	ax
   701 0000033A B400                    	mov	ah,0
   702 0000033C 01C2                    	add	dx,ax			; add the digit
   703 0000033E EBB7                    	jmp	.parse_port_loop
   704                                  
   705                                  .use_hex:
   706 00000340 80F900                  	cmp	cl,0			; already seen a hexdecimal identifier?
   707 00000343 7403E92502              	jne	invalid_argument
   708 00000348 83FA00                  	cmp	dx,0			; hex flag after a non-zero number?
   709 0000034B 7403E91D02              	jne	invalid_argument
   710 00000350 FEC1                    	inc	cl			; set hexadecimal flag
   711 00000352 EBA3                    	jmp	.parse_port_loop
   712                                  
   713                                  .port_check:
   714 00000354 83FA00                  	cmp	dx,0
   715 00000357 7503                    	jnz	.port_check_range
   716 00000359 BA4002                  	mov	dx,default_io_port	; DX==0, load the default address
   717                                  
   718                                  .port_check_range:
   719 0000035C 83FA70                  	cmp	dx,70h			; I/O port can be 70h on
   720                                  					; Micro 8088 / NuXT without 8088 BIOS?!
   721 0000035F 7412                    	je	.port_ok
   722 00000361 81FAFE03                	cmp	dx,3FEh			; I/O port shouldn't be above 3FEh
   723 00000365 7603E90C02              	ja	invalid_port
   724 0000036A 81FA0002                	cmp	dx,200h			; I/O port shouldn't be below 200h
   725 0000036E 7303E90302              	jb	invalid_port
   726                                  .port_ok:
   727 00000373 1F                      	pop	ds
   728 00000374 2E8916[1600]            	mov	cs:[rtc_io_port],dx	; store the port address
   729                                  
   730                                  ;-------------------------------------------------------------------------
   731                                  ; Check if we have a DS12885 RTC at the specified address
   732                                  
   733 00000379 B00A                    	mov	al,cmos_control_a	; select control A register
   734 0000037B B426                    	mov	ah,26h			; turn on oscillator and time keeping
   735                                  					; set SQW frequency to 1.024 KHz
   736 0000037D E8E4FE                  	call	rtc_write		; write control register A
   737                                  
   738 00000380 E8CCFE                  	call	rtc_read		; read back control A register
   739 00000383 3C26                    	cmp	al,26h
   740 00000385 7403E9CE01              	jne	no_rtc
   741                                  
   742                                  ; Continue with the RTC initialization
   743                                  
   744 0000038A B402                    	mov	ah,cmos_24hours		; set 24 hours bit, select CD format
   745                                  					; and keep interrupts disabled
   746 0000038C 2E0A26[FC07]            	or	ah,cs:[dse]		; set DSE bit according to the cmd opt.
   747 00000391 B00B                    	mov	al,cmos_control_b
   748                                  
   749 00000393 E8CEFE                  	call	rtc_write		; write control register B
   750                                  
   751 00000396 B00C                    	mov	al,cmos_control_c
   752 00000398 E8B4FE                  	call	rtc_read		; read control register C - reset
   753                                  					; interrupt flags
   754                                  
   755 0000039B B00D                    	mov	al,cmos_control_d
   756 0000039D E8AFFE                  	call	rtc_read		; read control register D
   757 000003A0 A880                    	test	al,cmos_vrt
   758 000003A2 753F                    	jnz	.battery_good		; RTC battery is good
   759                                  
   760                                  ; Battery is bad
   761                                  
   762 000003A4 BA[6A06]                	mov	dx,msg_rtc_batt
   763 000003A7 E8ED01                  	call	print_string
   764                                  
   765                                  ; Set initial time and date - Monday, January 1st, 2024, 00:00:00
   766                                  
   767                                  .reset_clock:
   768 000003AA BA[8C06]                	mov	dx,msg_rtc_inval
   769 000003AD E8E701                  	call	print_string
   770 000003B0 2EC606[2700]20          	mov	byte cs:[century+1],20h	; 20h
   771 000003B6 2EC606[2500]24          	mov	byte cs:[year+1],24h	; 24h
   772 000003BC 2EC606[2300]01          	mov	byte cs:[month+1],1	; January
   773 000003C2 2EC606[2100]01          	mov	byte cs:[date+1],1	; 1st
   774 000003C8 2EC606[1F00]02          	mov	byte cs:[day+1],2	; Monday
   775 000003CE 2EC606[1D00]00          	mov	byte cs:[hours+1],0
   776 000003D4 2EC606[1B00]00          	mov	byte cs:[minutes+1],0
   777 000003DA 2EC606[1900]00          	mov	byte cs:[seconds+1],0
   778 000003E0 E801FE                  	call	rtc_set
   779                                  
   780                                  .battery_good:
   781                                  
   782                                  ;-------------------------------------------------------------------------
   783                                  ; Set BIOS timer variables to RTC time
   784                                  
   785 000003E3 E836FE                  	call	rtc_get
   786                                  
   787                                  ; Validate date and time
   788                                  
   789 000003E6 2EA0[2700]              	mov	al,cs:[century+1]
   790 000003EA E890FE                  	call	bcd_to_binary
   791 000003ED 3C14                    	cmp	al,20			; century must be between 19 and 20
   792 000003EF 77B9                    	ja	.reset_clock
   793 000003F1 3C13                    	cmp	al,19
   794 000003F3 72B5                    	jb	.reset_clock
   795                                  
   796 000003F5 2EA0[2500]              	mov	al,cs:[year+1]
   797 000003F9 E881FE                  	call	bcd_to_binary
   798 000003FC 3C63                    	cmp	al,99			; year must be between 0 and 99
   799 000003FE 77AA                    	ja	.reset_clock
   800 00000400 88C1                    	mov	cl,al			; save the year value in CL
   801                                  
   802 00000402 2EA0[2300]              	mov	al,cs:[month+1]
   803 00000406 E874FE                  	call	bcd_to_binary
   804 00000409 3C0C                    	cmp	al,12			; month must be between 1 and 12
   805 0000040B 779D                    	ja	.reset_clock
   806 0000040D 3C01                    	cmp	al,1
   807 0000040F 7299                    	jb	.reset_clock
   808 00000411 88C5                    	mov	ch,al			; save the month value to CH
   809                                  
   810                                  ; check for February in a leap year
   811                                  
   812 00000413 B400                    	mov	ah,0
   813 00000415 FEC8                    	dec	al			; AX - month 0 to 11
   814 00000417 BE[2A00]                	mov	si,days_in_month
   815 0000041A 01C6                    	add	si,ax			; [SI] - days in the current month
   816 0000041C 2EA0[2100]              	mov	al,cs:[date+1]
   817 00000420 E85AFE                  	call	bcd_to_binary
   818 00000423 3C01                    	cmp	al,1			; day must be above or equal to 1
   819 00000425 7283                    	jb	.reset_clock
   820 00000427 2E8A24                  	mov	ah,cs:[si]		; AH - number of days in the month
   821 0000042A 80FD02                  	cmp	ch,2			; is it Febuary?
   822 0000042D 7507                    	jne	.check_date
   823 0000042F 80C903                  	or	cl,3			; is it a leap year
   824 00000432 7502                    	jnz	.check_date
   825 00000434 FEC4                    	inc	ah			; increment number of days for leap year
   826                                  
   827                                  .check_date:
   828 00000436 38E0                    	cmp	al,ah			; AL - current date
   829 00000438 7603E96DFF              	ja	.reset_clock		; AH - days in this month
   830                                  
   831 0000043D 2EA0[1F00]              	mov	al,cs:[day+1]
   832 00000441 3C07                    	cmp	al,7			; day must be between 1 and 7
   833 00000443 7603E962FF              	ja	.reset_clock
   834 00000448 3C01                    	cmp	al,1
   835 0000044A 7303E95BFF              	jb	.reset_clock
   836 0000044F 2EA0[1D00]              	mov	al,cs:[hours+1]
   837 00000453 E827FE                  	call	bcd_to_binary
   838 00000456 3C17                    	cmp	al,23			; hours must be between 0 and 23
   839 00000458 7603E94DFF              	ja	.reset_clock
   840 0000045D 2EA0[1B00]              	mov	al,cs:[minutes+1]
   841 00000461 E819FE                  	call	bcd_to_binary
   842 00000464 3C3B                    	cmp	al,59			; minutes must be between 0 and 59
   843 00000466 7603E93FFF              	ja	.reset_clock
   844 0000046B 2EA0[1900]              	mov	al,cs:[seconds+1]
   845 0000046F E80BFE                  	call	bcd_to_binary
   846 00000472 3C3B                    	cmp	al,59			; seconds must be between 0 and 59
   847 00000474 7603E931FF              	ja	.reset_clock
   848                                  
   849 00000479 53                      	push	bx
   850                                  
   851                                  ; convert time to ticks * 2^11
   852                                  
   853                                  ; ticks = seconds * 37287
   854 0000047A 2EA0[1900]              	mov	al,cs:[seconds+1]
   855 0000047E E8FCFD                  	call	bcd_to_binary		; convert seconds to binary
   856                                  
   857 00000481 BAA791                  	mov	dx,37287
   858 00000484 F7E2                    	mul	dx			; DX:AX = seconds * 37287
   859                                  
   860 00000486 89C6                    	mov	si,ax
   861 00000488 89D7                    	mov	di,dx
   862                                  
   863                                  ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   864 0000048A 2EA0[1B00]              	mov	al,cs:[minutes+1]
   865 0000048E E8ECFD                  	call	bcd_to_binary		; convert minutes to binary
   866                                  
   867 00000491 89C3                    	mov	bx,ax
   868 00000493 BA2023                  	mov	dx,8992
   869 00000496 F7E2                    	mul	dx			; DX:AX = minutes * 8992
   870                                  
   871 00000498 01C6                    	add	si,ax
   872 0000049A 11D7                    	adc	di,dx
   873                                  
   874 0000049C 89D8                    	mov	ax,bx
   875 0000049E BA2200                  	mov	dx,34
   876 000004A1 F7E2                    	mul	dx
   877                                  
   878 000004A3 01C7                    	add	di,ax
   879                                  
   880                                  ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   881 000004A5 2EA0[1D00]              	mov	al,cs:[hours+1]
   882 000004A9 E8D1FD                  	call	bcd_to_binary		; convert hours to binary
   883                                  
   884 000004AC 89C3                    	mov	bx,ax
   885 000004AE BA6A3B                  	mov	dx,15210
   886 000004B1 F7E2                    	mul	dx			; DX:AX = hours * 15210
   887                                  
   888 000004B3 01C6                    	add	si,ax
   889 000004B5 11D7                    	adc	di,dx
   890                                  
   891 000004B7 89D8                    	mov	ax,bx
   892 000004B9 BA0008                  	mov	dx,2048
   893 000004BC F7E2                    	mul	dx			; AX = hours * 2048
   894                                  
   895 000004BE 01C7                    	add	di,ax
   896                                  
   897                                  ; CX:DX = DI:SI / 2048
   898 000004C0 B10B                    	mov	cl,11
   899 000004C2 D3EE                    	shr	si,cl
   900 000004C4 89FA                    	mov	dx,di
   901 000004C6 B105                    	mov	cl,5
   902 000004C8 D3E2                    	shl	dx,cl
   903 000004CA 09F2                    	or	dx,si
   904                                  
   905 000004CC B10B                    	mov	cl,11
   906 000004CE D3EF                    	shr	di,cl
   907 000004D0 89F9                    	mov	cx,di
   908                                  					; CX = high word of tick count
   909                                  					; DX = low word of tick count
   910 000004D2 B401                    	mov	ah,01h			; int 1Ah, function 01h - set time
   911 000004D4 CD1A                    	int	1Ah
   912 000004D6 5B                      	pop	bx
   913                                  
   914                                  ;-------------------------------------------------------------------------
   915                                  ; Print the RTC I/O port number
   916                                  
   917 000004D7 BA[2406]                	mov	dx,msg_rtc_port
   918 000004DA E8BA00                  	call	print_string
   919 000004DD 2EA1[1600]              	mov	ax,cs:[rtc_io_port]
   920 000004E1 E8C900                  	call	print_hex
   921                                  
   922                                  ; Print current date and time
   923                                  
   924 000004E4 BA[3B06]                	mov	dx,msg_rtc_time
   925 000004E7 E8AD00                  	call	print_string
   926                                  
   927 000004EA 2E8A26[2700]            	mov	ah,cs:[century+1]
   928 000004EF 2EA0[2500]              	mov	al,cs:[year+1]
   929 000004F3 E8B700                  	call	print_hex		; print 4-digit year
   930                                  
   931 000004F6 B02D                    	mov	al,'-'			; print a dash (-)
   932 000004F8 E8A900                  	call	print_char
   933                                  
   934 000004FB 2EA0[2300]              	mov	al,cs:[month+1]
   935 000004FF E8B600                  	call	print_byte		; print 2-digit month
   936                                  
   937 00000502 B02D                    	mov	al,'-'			; print a dash (-)
   938 00000504 E89D00                  	call	print_char
   939                                  
   940 00000507 2EA0[2100]              	mov	al,cs:[date+1]
   941 0000050B E8AA00                  	call	print_byte		; print 2-digit date
   942                                  
   943 0000050E B020                    	mov	al,' '			; print a space
   944 00000510 E89100                  	call	print_char
   945                                  
   946 00000513 2EA0[1D00]              	mov	al,cs:[hours+1]
   947 00000517 E89E00                  	call	print_byte		; print 2-digit hours
   948                                  	
   949 0000051A B03A                    	mov	al,':'			; print a colon (:)
   950 0000051C E88500                  	call	print_char
   951                                  
   952 0000051F 2EA0[1B00]              	mov	al,cs:[minutes+1]
   953 00000523 E89200                  	call	print_byte		; print 2-digit minutes
   954                                  	
   955 00000526 B03A                    	mov	al,':'			; print a colon (:)
   956 00000528 E87900                  	call	print_char
   957                                  
   958 0000052B 2EA0[1900]              	mov	al,cs:[seconds+1]
   959 0000052F E88600                  	call	print_byte		; print 2-digit seconds
   960                                  
   961 00000532 BA[4D06]                	mov	dx,msg_rtc_dse_ena	; assume DSE is enabled
   962 00000535 2E803E[FC07]01          	cmp	byte cs:[dse],cmos_dse	; is it really enabled?
   963 0000053B 7403                    	je	.print_dse
   964 0000053D BA[5B06]                	mov	dx,msg_rtc_dse_dis
   965                                  
   966                                  .print_dse:
   967 00000540 E85400                  	call	print_string
   968                                  
   969 00000543 BA[F907]                	mov	dx,msg_cr_lf
   970 00000546 E84E00                  	call	print_string
   971                                  
   972 00000549 C7470E[9902]            	mov	word [bx+end_addr],init	; resident part ends at "init"
   973 0000054E 8C4F10                  	mov	[bx+end_addr+2],cs
   974 00000551 C6470D01                	mov	byte [bx+num_units],1	; 1 unit, keeps DOS happy?!
   975                                  
   976 00000555 E91AFB                  	jmp	exit
   977                                  	
   978                                  no_rtc:
   979 00000558 52                      	push	dx
   980 00000559 BA[C806]                	mov	dx,msg_no_rtc
   981 0000055C E83800                  	call	print_string
   982 0000055F 5A                      	pop	dx
   983 00000560 89D0                    	mov	ax,dx
   984 00000562 E84800                  	call	print_hex
   985 00000565 BA[F907]                	mov	dx,msg_cr_lf
   986 00000568 E82C00                  	call	print_string
   987 0000056B EB1B                    	jmp	init_error
   988                                  	
   989                                  invalid_argument:
   990 0000056D 1F                      	pop	ds
   991 0000056E BA[1207]                	mov	dx,msg_inv_arg
   992 00000571 E82300                  	call	print_string
   993 00000574 EB12                    	jmp	init_error
   994                                  
   995                                  invalid_port:
   996 00000576 1F                      	pop	ds
   997 00000577 89D0                    	mov	ax,dx
   998 00000579 BA[F306]                	mov	dx,msg_inv_port
   999 0000057C E81800                  	call	print_string
  1000 0000057F E82B00                  	call	print_hex
  1001 00000582 BA[3707]                	mov	dx,msg_usage
  1002 00000585 E80F00                  	call	print_string
  1003                                  
  1004                                  init_error:
  1005                                  
  1006 00000588 C7470E0000              	mov	word [bx+end_addr],0	; not staying in memory
  1007 0000058D 8C4F10                  	mov	[bx+end_addr+2],cs
  1008 00000590 C6470D01                	mov	byte [bx+num_units],1	; 1 unit, keeps DOS happy?!
  1009                                  
  1010 00000594 E9D6FA                  	jmp	error
  1011                                  
  1012                                  ;=========================================================================
  1013                                  ; print_string - print '$' terminated string
  1014                                  ; Input:
  1015                                  ;	CS:DX - string to print
  1016                                  ; Output:
  1017                                  ;	none, string printed
  1018                                  ;-------------------------------------------------------------------------
  1019                                  print_string:
  1020 00000597 50                      	push	ax
  1021 00000598 1E                      	push	ds
  1022 00000599 8CC8                    	mov	ax,cs
  1023 0000059B 8ED8                    	mov	ds,ax
  1024 0000059D B409                    	mov	ah,09h
  1025 0000059F CD21                    	int	21h			; DOS function 09h - print string
  1026 000005A1 1F                      	pop	ds
  1027 000005A2 58                      	pop	ax
  1028 000005A3 C3                      	ret
  1029                                  
  1030                                  ;=========================================================================
  1031                                  ; print_char - print character
  1032                                  ; Input:
  1033                                  ;	AL - character to print
  1034                                  ; Output:
  1035                                  ;	none, character printed
  1036                                  ;	AH - trashed
  1037                                  ;-------------------------------------------------------------------------
  1038                                  print_char:
  1039 000005A4 52                      	push	dx
  1040 000005A5 B402                    	mov	ah,02h
  1041 000005A7 88C2                    	mov	dl,al			; character to print
  1042 000005A9 CD21                    	int	21h			; DOS function 02h - print character
  1043 000005AB 5A                      	pop	dx
  1044 000005AC C3                      	ret
  1045                                  
  1046                                  ;=========================================================================
  1047                                  ; print_hex - print 16-bit number in hexadecimal format
  1048                                  ; Input:
  1049                                  ;	AX - number to print
  1050                                  ; Output:
  1051                                  ;	none
  1052                                  ;-------------------------------------------------------------------------
  1053                                  print_hex:
  1054 000005AD 86E0                    	xchg	al,ah
  1055 000005AF E80600                  	call	print_byte		; print the upper byte
  1056 000005B2 86E0                    	xchg	al,ah
  1057 000005B4 E80100                  	call	print_byte		; print the lower byte
  1058 000005B7 C3                      	ret
  1059                                  
  1060                                  ;=========================================================================
  1061                                  ; print_byte - print a byte in hexadecimal
  1062                                  ; Input:
  1063                                  ;	AL - byte to print
  1064                                  ; Output:
  1065                                  ;	none
  1066                                  ;-------------------------------------------------------------------------
  1067                                  print_byte:
  1068 000005B8 D0C0                    	rol	al,1
  1069 000005BA D0C0                    	rol	al,1
  1070 000005BC D0C0                    	rol	al,1
  1071 000005BE D0C0                    	rol	al,1
  1072 000005C0 E80C00                  	call	print_digit
  1073 000005C3 D0C0                    	rol	al,1
  1074 000005C5 D0C0                    	rol	al,1
  1075 000005C7 D0C0                    	rol	al,1
  1076 000005C9 D0C0                    	rol	al,1
  1077 000005CB E80100                  	call	print_digit
  1078 000005CE C3                      	ret	
  1079                                  
  1080                                  ;=========================================================================
  1081                                  ; print_digit - print hexadecimal digit
  1082                                  ; Input:
  1083                                  ;	AL - bits 3...0 - digit to print (0...F)
  1084                                  ; Output:
  1085                                  ;	none
  1086                                  ;-------------------------------------------------------------------------
  1087                                  print_digit:
  1088 000005CF 50                      	push	ax
  1089 000005D0 240F                    	and	al,0Fh
  1090 000005D2 0430                    	add	al,'0'			; convert to ASCII
  1091 000005D4 3C39                    	cmp	al,'9'			; less or equal 9?
  1092 000005D6 7602                    	jna	.1
  1093 000005D8 0407                    	add	al,'A'-'9'-1		; a hex digit
  1094                                  .1:
  1095 000005DA E8C7FF                  	call	print_char
  1096 000005DD 58                      	pop	ax
  1097 000005DE C3                      	ret
  1098                                  
  1099                                  ;=========================================================================
  1100                                  ; Messages for the initialization routine
  1101                                  
  1102 000005DF 445331323838352052-     msg_signin	db	'DS12885 RTC Driver, Version 1.1. '
  1102 000005E8 544320447269766572-
  1102 000005F1 2C2056657273696F6E-
  1102 000005FA 20312E312E20       
  1103 00000600 436F70797269676874-     		db	'Copyright (C) 2024 Sergey Kiselev'
  1103 00000609 202843292032303234-
  1103 00000612 20536572676579204B-
  1103 0000061B 6973656C6576       
  1104 00000621 0D0A24                  		db	0Dh, 0Ah, '$'
  1105 00000624 525443206174207468-     msg_rtc_port	db	'RTC at the I/O port 0x$'
  1105 0000062D 6520492F4F20706F72-
  1105 00000636 7420307824         
  1106 0000063B 3B204461746520616E-     msg_rtc_time	db	'; Date and time: $'
  1106 00000644 642074696D653A2024 
  1107 0000064D 3B2044534520656E61-     msg_rtc_dse_ena	db	'; DSE enabled$'
  1107 00000656 626C656424         
  1108 0000065B 3B2044534520646973-     msg_rtc_dse_dis	db	'; DSE disabled$'
  1108 00000664 61626C656424       
  1109 0000066A 5761726E696E673A20-     msg_rtc_batt	db	'Warning: The RTC battery is bad', 0Dh, 0Ah, '$'
  1109 00000673 546865205254432062-
  1109 0000067C 617474657279206973-
  1109 00000685 206261640D0A24     
  1110 0000068C 075761726E696E673A-     msg_rtc_inval	db	07h, 'Warning: Invalid date or time. '
  1110 00000695 20496E76616C696420-
  1110 0000069E 64617465206F722074-
  1110 000006A7 696D652E20         
  1111 000006AC 53657474696E672074-     		db	'Setting to default values', 0Dh, 0Ah, '$'
  1111 000006B5 6F2064656661756C74-
  1111 000006BE 2076616C7565730D0A-
  1111 000006C7 24                 
  1112 000006C8 074572726F723A204E-     msg_no_rtc	db	07h, 'Error: No RTC detected at the I/O port 0x$'
  1112 000006D1 6F2052544320646574-
  1112 000006DA 656374656420617420-
  1112 000006E3 74686520492F4F2070-
  1112 000006EC 6F727420307824     
  1113 000006F3 074572726F723A2049-     msg_inv_port	db	07h, 'Error: Invalid port number 0x$'
  1113 000006FC 6E76616C696420706F-
  1113 00000705 7274206E756D626572-
  1113 0000070E 20307824           
  1114 00000712 074572726F723A2049-     msg_inv_arg	db	07h, 'Error: Invalid command line argument'
  1114 0000071B 6E76616C696420636F-
  1114 00000724 6D6D616E64206C696E-
  1114 0000072D 6520617267756D656E-
  1114 00000736 74                 
  1115 00000737 0D0A55736167653A20-     msg_usage	db	0Dh, 0Ah, 'Usage: DSCLOCK.SYS [port] [/D]', 0Dh, 0Ah
  1115 00000740 4453434C4F434B2E53-
  1115 00000749 5953205B706F72745D-
  1115 00000752 205B2F445D0D0A     
  1116 00000759 2020706F7274202D20-     		db	'  port - decimal or hexadecimal RTC I/O port number.'
  1116 00000762 646563696D616C206F-
  1116 0000076B 722068657861646563-
  1116 00000774 696D616C2052544320-
  1116 0000077D 492F4F20706F727420-
  1116 00000786 6E756D6265722E     
  1117 0000078D 0D0A20202020537570-     		db	0Dh, 0Ah, '    Supported port range is 0x200 - 0x3FF'
  1117 00000796 706F7274656420706F-
  1117 0000079F 72742072616E676520-
  1117 000007A8 697320307832303020-
  1117 000007B1 2D203078334646     
  1118 000007B8 0D0A20202F44202020-     		db	0Dh, 0Ah, '  /D   - enable daylight saving.'
  1118 000007C1 2D20656E61626C6520-
  1118 000007CA 6461796C6967687420-
  1118 000007D3 736176696E672E     
  1119 000007DA 0D0A4578616D706C65-     		db	0Dh, 0Ah, 'Example: DSCLOCK.SYS 0x240 /D'
  1119 000007E3 3A204453434C4F434B-
  1119 000007EC 2E5359532030783234-
  1119 000007F5 30202F44           
  1120 000007F9 0D0A24                  msg_cr_lf	db	0Dh, 0AH, '$'
  1121                                  
  1122                                  ; Data for the initialization routine
  1123 000007FC 00                      dse		db	0		; DSE flag: 0 - disable; 1 - enable
